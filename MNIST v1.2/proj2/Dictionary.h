#pragma once

#include <iostream>
#include <string>
#include <process.h>
#include <conio.h>
#include <list>
#include <vector>

#ifndef DICTIONARY_HEADER
#define DICTIONARY_HEADER
using namespace std;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////*ENTRY*//////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
class Entry {
private:
	K KEY;															//key of entry
	V VALUE;														//value of entry
public:
	Entry(K k = K(), const V& v = V()) : KEY(k), VALUE(v) { }		//constructor
	const K& key() const { return KEY; }							//returns const reference to KEY
	const V& value() const { return VALUE; }						//returns const reference to VALUE
	void setKey(K k) { KEY = k; }									//sets KEY to k
	void setValue(V v) { VALUE = v; }								//sets VALUE to v
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////*Dictionary*//////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
class Dictionary
{
private:
	typedef Entry<K, V> ENTRY;
	typedef list<ENTRY> Bucket;
	typedef typename Bucket::iterator BItor;
private:
	Bucket bkt;						//list of entries
	int SIZE;						//size of dictionary
	string NAME;					//name of dictionary
public:
	Dictionary(string name= "YOU DIDN'T GIVE IT A NAME!");  //constructor
	int  size();										    //return the size of dictionary
	bool empty();										    //return true if the dictionary is empty
	bool exist(K key);										//return true if key exists in the dictionary, else it prints err msg
	void put(K key, V value);								//put ENTRY(key,value) into dictionary, if the key already exists it prints err msg
	void erase(K key);										//removes the entry with key, if key does not exist it prints err msg
	void replace(K key,V value);                            //replaces the value of the entry with the provided key, if the key does not exist it prints err msg
	void clear();											//removes all entries in the dictionary
	void print();											//print all entries in the dictionary (assuming that the key could be directly printed and the value has its own print function)
	void setName(string name);                              //sets the dictionary name
	BItor find(K key);										//returns an iterator to the entry with key, if key does not exist it prints err msg
	const V& operator[](K key);								//returns a const refrence the the value of the entry with key
};
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
Dictionary<K,V>::Dictionary(string name) : SIZE(0), NAME(name)
{}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
int Dictionary<K, V>::size()
{
	return bkt.size();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
bool Dictionary<K, V>::empty()
{
	return size() == 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
bool Dictionary<K, V>::exist(K key)
{
	for (BItor i = bkt.begin(); i != bkt.end(); ++i)
	{
		if(i->key() == key)
			return true;
	}
	return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
typename Dictionary<K,V>::BItor Dictionary<K, V>::find(K key)
{
	for (BItor i = bkt.begin(); i != bkt.end(); ++i)
	{
		if(i->key() == key)
			return i;
	}
	cout << "This key does not exist!" << endl;
	return bkt.end();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
void Dictionary<K,V>::put(K key, V value)
{
	if (exist(key))
		cout << "This key is used before!" << endl;
	else
	{
		bkt.push_front(ENTRY(key, value));
		SIZE++;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
void Dictionary<K,V>::replace(K key,V value)
{
    if (!exist(key))
		cout << "This key does not exist!" << endl;
    else
    {
        BItor i = find(key);
        i->setValue(value);
    }

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
void Dictionary<K, V>::erase(K key)
{
	if (!exist(key))
		cout << "This key does not exist!" << endl;
	else
	{
		BItor i = find(key);
		bkt.erase(i);
		SIZE--;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
void Dictionary<K, V>::clear()
{
	bkt.clear();
	SIZE = 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
const V& Dictionary<K, V>::operator[](K key)
{
	if (exist(key))
	{
		BItor i = find(key);
		return i->value();
	}
	cout << "This key does not exist!" << endl << endl;
	cout << "Press enter to end.." << endl;
	_getche();
	exit(0);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
void Dictionary<K, V>::print()
{
	cout << endl << "The size of " << NAME << " : " << SIZE << endl;
	cout << endl << "The contents of " << NAME << " :" << endl << endl;
	for (BItor i = bkt.begin(); i != bkt.end(); ++i)
	{
		cout << i->key() << endl;
		i->value().print();
		cout << endl;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename K, typename V>
void Dictionary<K, V>::setName(string name)
{
    NAME=name;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif // !DICTIONARY_HEADER
