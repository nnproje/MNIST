#include "NeuralNetwork.h"

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NeuralNetwork::NeuralNetwork(TypeOfNet TN)
{
	 NetType = TN;
	 FC_Cache.setName("FC_Cache");
     FC_Parameters.setName("FC_Parameters");
     FC_Grades.setName("FC_Grades");
     Conv_biases.setName("Conv_biases");
     Conv_Weights.setName("Conv_Weights");
     Conv_Cache.setName("Conv_Cache");
     Conv_dbiases.setName("Conv_dbiases");
     Conv_Grades.setName("Conv_Grades");
	 ADAM_dWC.setName("ADAM_dWC");
	 ADAM_dbC.setName("ADAM_dbC");
	 if (NetType == LENET1)
	 {
		 init_LeNet1();
	 }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
NeuralNetwork::NeuralNetwork(TypeOfNet TN, layer* Layers, int L)
{
     layers = Layers;
     numOfLayers = L;
     NetType = TN;
	 FC_Cache.setName("FC_Cache");
     FC_Parameters.setName("FC_Parameters");
     FC_Grades.setName("FC_Grades");
     init_FC();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void NeuralNetwork::train(Matrix* X, Matrix* Y, Matrix* X_div, Matrix* Y_div, float alpha, int numOfEpochs, int minibatchSize, Optimizer Op, int Numprint, ErrorType ET, float lambda, bool batchNorm, bool dropout, float* keep_prob)
{
	switch (NetType)
	{
	case FC:
		train_FC(X, Y, X_div, Y_div, alpha, numOfEpochs, minibatchSize, Op, Numprint, ET, lambda, batchNorm, dropout, keep_prob);
		break;
	case LENET1:
		train_LeNet1(X, Y, X_div, Y_div, alpha, numOfEpochs, minibatchSize, Op, Numprint, ET, lambda, batchNorm, dropout, keep_prob);
		break;
	}
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void NeuralNetwork::test(Matrix* X_test, Matrix* Y_test, string path, Mode devOrtest, bool batchNorm, bool dropout, float* keep_prob)
{
	/******************get Y_hat********************************/
	Matrix* Y_hat = nullptr;
	switch (NetType)
	{
	case FC:
		Y_hat = test_FC(X_test, Y_test, batchNorm, false, keep_prob);
		AccuracyTest(Y_test, Y_hat, "test");
		FC_Cache.DeleteThenClear();
		break;
	case LENET1:
		Y_hat = test_LeNet1(X_test, Y_test, batchNorm, false, keep_prob);
		AccuracyTest(Y_test, Y_hat, "test");
		FC_Cache.DeleteThenClear();
        Conv_Cache.DeleteThenClearObj();
		break;
	}

}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
